package patmat
import common._
import patmat._
import patmat.Huffman._



object Huff {
  println("Welcome to the Scala worksheet")       //> Welcome to the Scala worksheet
  
  
  implicit def double2int(d:Double): Int = d.toInt//> double2int: (d: Double)Int
  
  val i: Int = 2.2                                //> i  : Int = 2
  
  
//  abstract class CodeTree
//  case class Fork(left: CodeTree, right: CodeTree, chars: List[Char], weight: Int) extends CodeTree
//  case class Leaf(char: Char, weight: Int) extends CodeTree
//  implicit def pairToLeaf(char: Char, weight: Int): Leaf = new Leaf('a',3)

  val t0 = ('a',2)                                //> t0  : (Char, Int) = (a,2)
  
  implicit def tupleToLeaf(t: (Char, Int)): Leaf = t match { case (c,n) => Leaf(c,n) }
                                                  //> tupleToLeaf: (t: (Char, Int))patmat.Huffman.Leaf
  implicit def leafToTuple(l: Leaf): Leaf = l match { case Leaf(c,n) => (c,n) }
                                                  //> leafToTuple: (l: patmat.Huffman.Leaf)patmat.Huffman.Leaf
  
  val l0 = Leaf('a',2)                            //> l0  : patmat.Huffman.Leaf = Leaf(a,2)
  val l1: Leaf = t0                               //> l1  : patmat.Huffman.Leaf = Leaf(a,2)
  
  val data = string2Chars("abbccc")               //> data  : List[Char] = List(a, b, b, c, c, c)
  val acc = List()                                //> acc  : List[Nothing] = List()

  
  val tbl3 = Huffman.times(data)                  //> tbl3  : List[(Char, Int)] = List((a,1), (b,2), (c,3))
  
  val leaflist = List(Leaf('e', 1), Leaf('t', 2), Leaf('x', 4))
                                                  //> leaflist  : List[patmat.Huffman.Leaf] = List(Leaf(e,1), Leaf(t,2), Leaf(x,4)
                                                  //| )
  val foo = combine(leaflist)                     //> foo  : List[patmat.Huffman.CodeTree] = List()
  
  
  
  
  
  
  
    
  
  
}